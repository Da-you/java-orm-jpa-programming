# 패러다임의 불일치

- 객체 지향 프로그래밍은 추상화, 캡슐화, 정보은닝, 상속, 다형성을 제공
- 관계형 데이터베이스는 데이터 중심으로 구조화되어 추상화, 상속, 다형성 같은 개념이 없다.
---

### 상속
- DB 모델링에서는 슈퍼타입-서브타입을 이용해 상속과 유사한 형태로 설계갸 가능
- DTYPE 컬럼을 사용해 어떤 서브타입 테이블과 관계가 있는지 정의해야 함.
  - 저장을 할때에는 슈퍼타입, 서브타입을 저장하는 SQL을 각각 정의해야 함.
  - 조회할 경우 JOIN을 이용해야 함

#### JPA와 상속
- JPA에서 제공하는 저장 API를 사용하면 슈퍼타입, 서브타입을 알아서 SQL을 생성해 저장함
- 조회시에도 JPA 제공 API인 find()를 사용하면 두 테이블을 JOIN하여 조회하고 그 결과를 반환
- 객체 지향과 RDB 사이에 존재하는 패러다임의 불일치를 JPA가 개발자 대신 해결

### 연관관계
- 객체는 참조를 사용해 다른 객체와 연관관계를 가지고 참조를 이용해 연관 객체를 조회
- 테이블은 외래 키를 사용해 다른 테이블과 연관관계를 가지며 JOIN을 이용해 연관 테이블 조회
- 참조를 사용하는 객체와 외래 키를 이용하는 테이블의 패러다임 불일치의 해결은 어려움

#### JPA와 연관관계
- 회원과 팀이라는 두 객체가 존재할 때 개발자는 회원과 팀의 관계를 설정하고 회원 객체만 저장하면 됨
- JPA가 팀 객체의 참조를 외래 키로변환해 적적한 INSERT SQL을 DB에 전달

### 객체 그래프 탐색
- 객체는 마음껏 객체 그래프를 탐색할 수 있어야 한다.
  - 예를들어 member.getOrder().getOrderItem.... 이렇게 이어 나가져야 함
- SQL을 직접 이용하면 처음 실행한 SQL에 따라 객체 그래프를 어디까지 탐색할 수 있는지 정해짐
  - 비즈니스 로직에 따라 이용하는 객체 그래프가 다르므로 언제 끊어질지 모를 객체 그래프를 탐색하는 것은 위험
  - 즉 비즈니스 로직에 따른 객체 그래프 탐색 SQL을 작성해야 함.

#### JPA와 객체 그래프 탐색
- JPA는 '지연로딩'을 사용하는데 이는 실제 객체를 사용하는 시점까지 데이터베이스 조회를 미룸
  - 이로 인해 연관괸 객체를 신뢰하고 마음껏 조회 가능
- JPA는 연관된 관계를 즉시 로딩할지, 지연로딩할지 선택이 가능
  - 지연로딩시 JPA는 JOIN을 사용해 연관된 객체를 함께 조회
```
// 처음 조회 시점에 SELECT MEMBER SQL 실행
Member member  = jpa.find(Member.class, memberId);

Order order = member.getOrder();
order.getOrederDate(); // Oreder를 사용하는 시점에 SELECT ORDER SQL 실행
```

### 비교
- 데이터베이스는 기본 키의 값으로 각 row를 구분함
- 객체는 동일성과 동등성이라는 두 가지 방법이 존재
  - 동일성은 '==' 으로 객체 인스턴스의 주소값 비교
  - 동등성은 '.equals()'로 객체 내부의 값을 비교
```
String memberId = "100";
Member member1 = memberDao.getMember(memberID);
Member member2 = memberDao.getMember(memberID);
member1 == member2; // false
```
- member1과 member2는 같은 데이터베이스 로우에서 조회했으나 객체 측면에서는 다른 인스턴스로 false를 반환

#### JPA와 비교
- JPA는 같은 트랜잭션일 댸 같은 객체가 조회되는 것을 보장
- ```
String memberId = "100";
Member member1 = jpa.getMember(memberID);
Member member2 = jpa.getMember(memberID);
member1 == member2; // true
```

###정리
- 객체 지향 모델과 관계형 데이터베이스 모델은 지향하는 패러다임이 다름
- 패러다임의 불일치를 개발자 대신 JPA가 처리해 정교한 객체 모델링을 유지하게 도와줌 